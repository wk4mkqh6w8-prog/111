import os
import logging
import threading
from datetime import datetime, timedelta

import requests
from dotenv import load_dotenv
from fastapi import FastAPI, Request
import uvicorn

from openai import OpenAI
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    Application, ApplicationBuilder,
    CommandHandler, CallbackQueryHandler, MessageHandler,
    ContextTypes, filters,
)

# ===============================
# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏ –∫–ª–∏–µ–Ω—Ç—ã
# ===============================
load_dotenv()

BOT_TOKEN = os.getenv("BOT_TOKEN", "")
OPENAI_KEY = os.getenv("OPENAI_KEY", "")
CRYPTOPAY_KEY = os.getenv("CRYPTOPAY_KEY")  # –º–æ–∂–µ—Ç –±—ã—Ç—å None
PORT = int(os.getenv("PORT", "10000"))

# –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –±–æ—Ç–∞: "123456789,987654321"
ADMIN_IDS_ENV = os.getenv("ADMIN_IDS", "")
ADMIN_IDS = {int(x) for x in ADMIN_IDS_ENV.replace(" ", "").split(",") if x.isdigit()}

if not BOT_TOKEN:
    raise RuntimeError("BOT_TOKEN –ø—É—Å—Ç. –î–æ–±–∞–≤—å –µ–≥–æ –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è Render.")
if not OPENAI_KEY:
    raise RuntimeError("OPENAI_KEY –ø—É—Å—Ç. –î–æ–±–∞–≤—å –µ–≥–æ –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è Render.")

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("neurobot")

client = OpenAI(api_key=OPENAI_KEY)

# –ë–î-—É—Ç–∏–ª–∏—Ç—ã
from db import (  # noqa: E402
    init_db, add_user, is_premium, can_send_message, set_premium,
    set_premium_days, remove_premium, get_user, stats,
    log_payment, sales_summary, daily_breakdown
)

# ============================================================================
# FastAPI + Telegram Application (webhook-only)
# ============================================================================
app = FastAPI(title="NeuroBot API")
application: Application | None = None
_public_url: str | None = None
_keepalive_stop = threading.Event()


# ===============================
# GPT
# ===============================
def ask_gpt(prompt: str) -> str:
    resp = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": prompt}],
        temperature=0.7,
    )
    return resp.choices[0].message.content


# ===============================
# –•—ç–Ω–¥–ª–µ—Ä—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
# ===============================
async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    await add_user(user.id)

    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton("üß† –í—ã–±—Ä–∞—Ç—å –Ω–µ–π—Ä–æ—Å–µ—Ç—å (–ø–æ–∫–∞ GPT-4o-mini)", callback_data="neuro")],
        [InlineKeyboardButton("üí≥ –ö—É–ø–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", callback_data="buy")],
    ])
    await update.message.reply_text(
        "–ü—Ä–∏–≤–µ—Ç! –Ø –Ω–µ–π—Ä–æ–±–æ—Ç ü§ñ\n\n"
        "–ë–µ—Å–ø–ª–∞—Ç–Ω–æ: 5 —Å–æ–æ–±—â–µ–Ω–∏–π –≤ –¥–µ–Ω—å.\n"
        "–ü—Ä–µ–º–∏—É–º ‚Äî –±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π –∏ –æ—á–µ—Ä–µ–¥–µ–π.\n\n"
        "–í—ã–±–∏—Ä–∞–π –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∏–∂–µ:",
        reply_markup=kb,
    )


async def on_buy_btn(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    if not CRYPTOPAY_KEY:
        await query.message.reply_text(
            "üí≥ –û–ø–ª–∞—Ç–∞ –µ—â—ë –Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∞. –î–æ–±–∞–≤—å CRYPTOPAY_KEY –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è Render."
        )
        return

    payload = str(query.from_user.id)
    headers = {"Crypto-Pay-API-Token": CRYPTOPAY_KEY}
    data = {
        "asset": "USDT",
        "amount": "3",
        "description": "–ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ 30 –¥–Ω–µ–π",
        "payload": payload,
    }
    try:
        r = requests.post(
            "https://pay.crypt.bot/api/createInvoice",
            json=data, headers=headers, timeout=15,
        )
        j = r.json()
        url = j["result"]["pay_url"]
        await query.message.reply_text(
            "üí≥ –û–ø–ª–∞—Ç–∏ –ø–æ–¥–ø–∏—Å–∫—É –ø–æ —Å—Å—ã–ª–∫–µ:\n"
            f"{url}\n\n"
            "–ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã –¥–æ—Å—Ç—É–ø –æ—Ç–∫—Ä–æ–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ ‚úÖ"
        )
    except Exception as e:
        await query.message.reply_text(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Å—á—ë—Ç: {e}")


async def on_neuro_btn(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.message.reply_text("–ü–æ–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ GPT-4o-mini. –î—Ä—É–≥–∏–µ –º–æ–¥–µ–ª–∏ –¥–æ–±–∞–≤–∏–º –ø–æ–∑–∂–µ üîß")


async def on_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    text = update.message.text or ""

    # –ü—Ä–µ–º–∏—É–º ‚Äî –±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π
    if await is_premium(user_id):
        try:
            reply = ask_gpt(text)
            await update.message.reply_text(reply)
        except Exception as e:
            await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ OpenAI: {e}")
        return

    # –ë–µ—Å–ø–ª–∞—Ç–Ω—ã–π –ª–∏–º–∏—Ç (5/–¥–µ–Ω—å)
    if await can_send_message(user_id, limit=5):
        try:
            reply = ask_gpt(text)
            await update.message.reply_text(reply)
        except Exception as e:
            await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ OpenAI: {e}")
    else:
        await update.message.reply_text(
            "üö´ –°–µ–≥–æ–¥–Ω—è –∏—Å—á–µ—Ä–ø–∞–Ω –ª–∏–º–∏—Ç –∏–∑ 5 —Å–æ–æ–±—â–µ–Ω–∏–π.\n"
            "–ö—É–ø–∏ –ø–æ–¥–ø–∏—Å–∫—É —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É ¬´üí≥ –ö—É–ø–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É¬ª, —á—Ç–æ–±—ã —Å–Ω—è—Ç—å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è."
        )


# ===============================
# –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å
# ===============================
def is_admin(user_id: int) -> bool:
    return user_id in ADMIN_IDS


ADMIN_HELP = (
    "üîê –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å:\n"
    "/whoami ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å —Ç–≤–æ–π id\n"
    "/stats ‚Äî –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –∏ –ø–æ–∫—É–ø–∫–∏ –∑–∞ —Å–µ–≥–æ–¥–Ω—è\n"
    "/sales ‚Äî –ø—Ä–æ–¥–∞–∂–∏: —Å–µ–≥–æ–¥–Ω—è / 7 –¥–Ω–µ–π / –≤—Å–µ–≥–æ + —Ä–∞–∑–±–∏–≤–∫–∞ –ø–æ –¥–Ω—è–º\n"
    "/status <tg_id> ‚Äî —Å—Ç–∞—Ç—É—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n"
    "/grant <tg_id> [–¥–Ω–µ–π] ‚Äî –≤—ã–¥–∞—Ç—å –ø—Ä–µ–º–∏—É–º (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 30)\n"
    "/revoke <tg_id> ‚Äî —Å–Ω—è—Ç—å –ø—Ä–µ–º–∏—É–º\n"
)


async def whoami(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(f"üÜî –í–∞—à Telegram ID: {update.effective_user.id}")


async def admin_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update.effective_user.id):
        return await update.message.reply_text("‚õî –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
    await update.message.reply_text(ADMIN_HELP)


async def cmd_stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update.effective_user.id):
        return await update.message.reply_text("‚õî –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
    s = await stats()
    await update.message.reply_text(
        "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ —Å–µ–≥–æ–¥–Ω—è:\n"
        f"‚Ä¢ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤—Å–µ–≥–æ: {s['total']}\n"
        f"‚Ä¢ –° –ø—Ä–µ–º–∏—É–º–æ–º: {s['premium']}\n"
        f"‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ–≥–æ–¥–Ω—è: {s['active_today']}\n"
        f"‚Ä¢ –ü–æ–∫—É–ø–æ–∫ —Å–µ–≥–æ–¥–Ω—è: {s['purchases_today']}"
    )


async def cmd_sales(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update.effective_user.id):
        return await update.message.reply_text("‚õî –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
    s = await sales_summary()
    days = await daily_breakdown(days=7)
    hist = "\n".join([f"‚Ä¢ {d}: {c}" for d, c in days])
    await update.message.reply_text(
        "üí≥ –ü—Ä–æ–¥–∞–∂–∏:\n"
        f"‚Ä¢ –°–µ–≥–æ–¥–Ω—è: {s['today']}\n"
        f"‚Ä¢ –ó–∞ 7 –¥–Ω–µ–π: {s['week']}\n"
        f"‚Ä¢ –í—Å–µ–≥–æ: {s['total']}\n\n"
        f"üìÖ –ü–æ –¥–Ω—è–º (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 7):\n{hist}"
    )


async def cmd_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update.effective_user.id):
        return await update.message.reply_text("‚õî –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
    if not context.args:
        return await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /status <tg_id>")
    try:
        uid = int(context.args[0])
    except Exception:
        return await update.message.reply_text("tg_id –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.")
    u = await get_user(uid)
    if not u:
        return await update.message.reply_text("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
    _, premium_until, messages_today, last_date = u
    await update.message.reply_text(
        "üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {uid}\n–ü—Ä–µ–º–∏—É–º –¥–æ: {pu}\n–°–æ–æ–±—â–µ–Ω–∏–π —Å–µ–≥–æ–¥–Ω—è: {m}\n–ü–æ—Å–ª–µ–¥–Ω—è—è –¥–∞—Ç–∞: {d}".format(
            uid=uid, pu=premium_until or "‚Äî", m=messages_today or 0, d=last_date or "‚Äî"
        )
    )


async def cmd_grant(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update.effective_user.id):
        return await update.message.reply_text("‚õî –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
    if not context.args:
        return await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /grant <tg_id> [–¥–Ω–µ–π]")
    try:
        uid = int(context.args[0])
        days = int(context.args[1]) if len(context.args) > 1 else 30
    except Exception:
        return await update.message.reply_text("tg_id –∏ –¥–Ω–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —á–∏—Å–ª–∞–º–∏.")
    await set_premium_days(uid, days)
    await update.message.reply_text(f"‚úÖ –í—ã–¥–∞–Ω –ø—Ä–µ–º–∏—É–º –Ω–∞ {days} –¥–Ω. –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {uid}")


async def cmd_revoke(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update.effective_user.id):
        return await update.message.reply_text("‚õî –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
    if not context.args:
        return await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /revoke <tg_id>")
    try:
        uid = int(context.args[0])
    except Exception:
        return await update.message.reply_text("tg_id –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.")
    await remove_premium(uid)
    await update.message.reply_text(f"‚úÖ –ü—Ä–µ–º–∏—É–º —Å–Ω—è—Ç —É {uid}")


# ===============================
# Webhook-—ç–Ω–¥–æ–∏–Ω—Ç—ã
# ===============================
@app.post("/tg")
async def telegram_webhook(request: Request):
    """
    –ü—Ä–∏–Ω–∏–º–∞–µ–º –∞–ø–¥–µ–π—Ç—ã –æ—Ç Telegram –∏ –ø—Ä–æ–∫–∏–¥—ã–≤–∞–µ–º –≤ PTB.
    """
    global application
    if application is None:
        return {"ok": False, "error": "bot not initialized"}

    data = await request.json()
    update = Update.de_json(data, application.bot)
    await application.process_update(update)
    return {"ok": True}


@app.post("/cryptopay-webhook")
async def cryptopay_webhook(request: Request):
    """
    –ü—Ä–∏–Ω–∏–º–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ—Ç CryptoBot:
    {
      "invoice": {
         "status": "paid",
         "payload": "<telegram_user_id>",
         "amount": "3",
         "asset": "USDT"
      }
    }
    """
    global application
    try:
        data = await request.json()
    except Exception:
        return {"ok": False, "error": "bad json"}

    invoice = data.get("invoice") or {}
    status = invoice.get("status")
    payload = invoice.get("payload")

    # –ø—Ä–æ–±—É–µ–º –∏–∑–≤–ª–µ—á—å —Å—É–º–º—É/–≤–∞–ª—é—Ç—É (–µ—Å–ª–∏ –µ—Å—Ç—å)
    amount = None
    try:
        if "amount" in invoice and invoice["amount"] is not None:
            amount = float(invoice["amount"])
    except Exception:
        amount = None
    asset = invoice.get("asset")

    if status == "paid" and payload:
        try:
            user_id = int(payload)
        except Exception:
            user_id = None

        if user_id:
            # –ª–æ–≥–∏—Ä—É–µ–º –æ–ø–ª–∞—Ç—É
            try:
                await log_payment(user_id, amount, asset)
            except Exception:
                pass

            # –≤—ã–¥–∞—ë–º –ø—Ä–µ–º–∏—É–º –Ω–∞ 30 –¥–Ω–µ–π
            expires_at = (datetime.now() + timedelta(days=30)).isoformat()
            await set_premium(user_id, expires_at)

            # —É–≤–µ–¥–æ–º–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            try:
                await application.bot.send_message(
                    chat_id=user_id,
                    text="‚úÖ –û–ø–ª–∞—Ç–∞ –ø–æ–ª—É—á–µ–Ω–∞! –ü–æ–¥–ø–∏—Å–∫–∞ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞ –Ω–∞ 30 –¥–Ω–µ–π.",
                )
            except Exception:
                pass

    return {"ok": True}


@app.get("/health")
async def health():
    return {"status": "ok", "time": datetime.utcnow().isoformat()}


# ===============================
# Keep-alive –ø–∏–Ω–≥
# ===============================
def _keepalive_loop():
    """
    –§–æ–Ω–æ–≤—ã–π –ø–æ—Ç–æ–∫: —Ä–∞–∑ –≤ 9 –º–∏–Ω—É—Ç –¥–µ—Ä–≥–∞–µ—Ç /health, —á—Ç–æ–±—ã –¥–µ—Ä–∂–∞—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Ç–µ–ø–ª—ã–º–∏,
    –ø–æ–∫–∞ –∏–Ω—Å—Ç–∞–Ω—Å –∞–∫—Ç–∏–≤–µ–Ω (–Ω–∞ Free Render –≤—Å—ë —Ä–∞–≤–Ω–æ –º–æ–∂–µ—Ç —É—Å–Ω—É—Ç—å –ø—Ä–∏ –¥–ª–∏—Ç–µ–ª—å–Ω–æ–º –ø—Ä–æ—Å—Ç–æ–µ).
    """
    if not _public_url:
        return
    url = f"{_public_url.rstrip('/')}/health"
    session = requests.Session()
    while not _keepalive_stop.wait(540):  # 9 –º–∏–Ω—É—Ç
        try:
            session.get(url, timeout=8)
            logger.debug("keep-alive ping %s", url)
        except Exception:
            pass


# ===============================
# –ñ–∏–∑–Ω–µ–Ω–Ω—ã–π —Ü–∏–∫–ª FastAPI
# ===============================
def build_application() -> Application:
    app_ = ApplicationBuilder().token(BOT_TOKEN).build()

    # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ
    app_.add_handler(CommandHandler("start", cmd_start))
    app_.add_handler(CallbackQueryHandler(on_buy_btn, pattern=r"^buy$"))
    app_.add_handler(CallbackQueryHandler(on_neuro_btn, pattern=r"^neuro$"))
    app_.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, on_message))

    # –ê–¥–º–∏–Ω—Å–∫–∏–µ
    app_.add_handler(CommandHandler("whoami", whoami))
    app_.add_handler(CommandHandler("admin", admin_menu))
    app_.add_handler(CommandHandler("stats", cmd_stats))
    app_.add_handler(CommandHandler("sales", cmd_sales))
    app_.add_handler(CommandHandler("status", cmd_status))
    app_.add_handler(CommandHandler("grant", cmd_grant))
    app_.add_handler(CommandHandler("revoke", cmd_revoke))

    return app_


@app.on_event("startup")
async def on_startup():
    global application, _public_url

    # 1) DB
    await init_db()

    # 2) Telegram Application
    application = build_application()
    await application.initialize()
    await application.start()

    # 3) Webhook
    _public_url = os.getenv("RENDER_EXTERNAL_URL") or os.getenv("PUBLIC_URL")
    if not _public_url:
        # –Ω–∞ Render RENDER_EXTERNAL_URL –ø–æ–¥—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
        raise RuntimeError("–ù–µ –Ω–∞–π–¥–µ–Ω PUBLIC_URL/RENDER_EXTERNAL_URL")

    webhook_url = f"{_public_url.rstrip('/')}/tg"
    await application.bot.set_webhook(webhook_url)
    logger.info("‚úÖ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω Telegram webhook: %s", webhook_url)

    # 4) Keep-alive
    threading.Thread(target=_keepalive_loop, daemon=True).start()

    logger.info("üöÄ Startup complete. Listening on port %s", PORT)


@app.on_event("shutdown")
async def on_shutdown():
    _keepalive_stop.set()
    try:
        if application is not None:
            try:
                await application.bot.delete_webhook(drop_pending_updates=False)
            except Exception:
                pass
            await application.stop()
            await application.shutdown()
    finally:
        logger.info("üõë Shutdown complete")


# ============================================================================
# –ó–∞–ø—É—Å–∫ –ª–æ–∫–∞–ª—å–Ω–æ / –Ω–∞ Render
# ============================================================================
if __name__ == "__main__":
    # –ù–∞ Render –ø—Ä–æ—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º Start Command:  python bot.py
    uvicorn.run(app, host="0.0.0.0", port=PORT)
